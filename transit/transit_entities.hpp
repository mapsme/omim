#pragma once

#include "base/macros.hpp"
#include "base/newtype.hpp"
#include "base/visitor.hpp"

#include "defines.hpp"

#include <cstdint>
#include <limits>
#include <string>
#include <unordered_map>
#include <vector>

#include "3party/opening_hours/opening_hours.hpp"

namespace routing
{
inline double constexpr kTransitMaxSpeedKMpH = 400.0;
}  // namespace routing

namespace transit
{
// File names for saving resulting data exported from GTFS.
inline std::string const kTransitFileExtension = std::string(TRANSIT_FILE_EXTENSION);
inline std::string const kNetworksFile = "networks" + kTransitFileExtension;
inline std::string const kRoutesFile = "routes" + kTransitFileExtension;
inline std::string const kLinesFile = "lines" + kTransitFileExtension;
inline std::string const kShapesFile = "shapes" + kTransitFileExtension;
inline std::string const kStopsFile = "stops" + kTransitFileExtension;
inline std::string const kEdgesFile = "edges" + kTransitFileExtension;
inline std::string const kEdgesTransferFile = "edges_transfer" + kTransitFileExtension;
inline std::string const kTransfersFile = "transfers" + kTransitFileExtension;
inline std::string const kGatesFile = "gates" + kTransitFileExtension;

// Unique id for transit entities. It is generated by gtfs_converter and is persistent between
// re-runs. Generated based on the unique string hash of the GTFS entity. Lies in the interval
// |routing::FakeFeatureIds::IsTransitFeature()|. If the GTFS entity is renamed or the new GTFS
// feed is added the new id is generated by |IdGenerator::MakeId()|.
using TransitId = uint32_t;
inline TransitId constexpr kInvalidTransitId = std::numeric_limits<TransitId>::max();

// Mapping of language id to text. Language id exists in |StringUtf8Multilang::kLanguages|.
using Translations = std::unordered_map<std::string, std::string>;

struct TimeFromGateToStop
{
  DECLARE_VISITOR_AND_DEBUG_PRINT(TimeFromGateToStop, visitor(m_stopId, "stopId"),
                                  visitor(m_timeSeconds, "timeSeconds"))

  TransitId m_stopId = kInvalidTransitId;
  size_t m_timeSeconds = 0;
};

struct LineInterval
{
  DECLARE_VISITOR_AND_DEBUG_PRINT(LineInterval, visitor(m_headwayS, "headwayS"),
                                  visitor(m_timeIntervals.GetRule(), "timeIntervals"))
  // Service interval in seconds between departures from the same stop (headway) for the line,
  // during the time interval specified by |m_timeIntervals|.
  size_t m_headwayS = 0;
  // Time interval for the |m_headwayS|. Multiple headways for the same trip are allowed, but may
  // not overlap in time.
  osmoh::OpeningHours m_timeIntervals;
};

using LineIntervals = std::vector<LineInterval>;
using IdList = std::vector<TransitId>;
using TimeTable = std::unordered_map<TransitId, osmoh::OpeningHours>;
using EdgeWeight = uint32_t;

// Link to the shape: shape id and indexes in the corresponding polyline.
struct ShapeLink
{
  DECLARE_VISITOR_AND_DEBUG_PRINT(ShapeLink, visitor(m_shapeId, "id"),
                                  visitor(m_startIndex, "startIndex"),
                                  visitor(m_endIndex, "endIndex"))

  TransitId m_shapeId = kInvalidTransitId;
  size_t m_startIndex = 0;
  size_t m_endIndex = 0;
};
}  // namespace transit
