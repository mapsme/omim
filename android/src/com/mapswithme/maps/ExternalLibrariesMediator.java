package com.mapswithme.maps;

import android.os.AsyncTask;
import android.os.Looper;
import android.support.annotation.NonNull;
import android.support.annotation.UiThread;
import android.text.TextUtils;

import com.appsflyer.AppsFlyerLib;
import com.crashlytics.android.Crashlytics;
import com.crashlytics.android.core.CrashlyticsCore;
import com.crashlytics.android.ndk.CrashlyticsNdk;
import com.google.android.gms.ads.identifier.AdvertisingIdClient;
import com.google.android.gms.common.GooglePlayServicesNotAvailableException;
import com.google.android.gms.common.GooglePlayServicesRepairableException;
import com.mapswithme.maps.bookmarks.OperationStatus;
import com.mapswithme.maps.content.DefaultEventLogger;
import com.mapswithme.maps.content.EventLogger;
import com.mapswithme.maps.content.EventLoggerAggregator;
import com.mapswithme.util.SharedPropertiesUtils;
import com.mapswithme.util.Utils;
import com.mopub.common.MoPub;
import com.mopub.common.SdkConfiguration;
import io.fabric.sdk.android.Fabric;

import java.io.IOException;

public class ExternalLibrariesMediator
{
  private boolean mCrashlyticsInitialized;

  @NonNull
  private final MwmApplication mApplication;

  @NonNull
  private EventLogger mEventLogger;

  public ExternalLibrariesMediator(@NonNull MwmApplication application)
  {
    mApplication = application;
    mEventLogger = new DefaultEventLogger(application);
    initSensitiveDataToleranceLibraries();
    initSensitiveDataStrictLibrariesAsync();
  }

  private void initSensitiveDataToleranceLibraries()
  {
    initMoPub();
    initCrashlytics();
    initAppsFlyer();
  }

  private void initSensitiveDataStrictLibrariesAsync()
  {
    GetAdInfoTask getAdInfoTask = new GetAdInfoTask(this);
    getAdInfoTask.execute();
  }

  private void initSensitiveDataStrictLibraries()
  {
    if (Looper.getMainLooper().getThread() != Thread.currentThread())
    {
      throw new IllegalStateException("Must be call from Ui thread");
    }

    mEventLogger = new EventLoggerAggregator(mApplication);
  }


  private void initAppsFlyer()
  {
    // There is no necessary to use a conversion data listener for a while.
    // When it's needed keep in mind that the core can't be used from the mentioned listener unless
    // the AppsFlyer sdk initializes after core initialization.
    AppsFlyerLib.getInstance().init(PrivateVariables.appsFlyerKey(),
                                    null /* conversionDataListener */);
    AppsFlyerLib.getInstance().setDebugLog(BuildConfig.DEBUG);
    AppsFlyerLib.getInstance().startTracking(mApplication);
  }

  public void initCrashlytics()
  {
    if (!isCrashlyticsEnabled())
      return;

    if (isCrashlyticsInitialized())
      return;

    Crashlytics core = new Crashlytics
        .Builder()
        .core(new CrashlyticsCore.Builder().disabled(!isFabricEnabled()).build())
        .build();

    Fabric.with(mApplication, core, new CrashlyticsNdk());
    nativeInitCrashlytics();
    mCrashlyticsInitialized = true;
  }

  public boolean isCrashlyticsEnabled()
  {
    return !BuildConfig.FABRIC_API_KEY.startsWith("0000");
  }

  private boolean isFabricEnabled()
  {
    String prefKey = mApplication.getResources().getString(R.string.pref_opt_out_fabric_activated);
    return MwmApplication.prefs(mApplication).getBoolean(prefKey, true);
  }

  @NonNull
  public EventLogger getEventLogger()
  {
    return mEventLogger;
  }

  public boolean isCrashlyticsInitialized()
  {
    return mCrashlyticsInitialized;
  }

  boolean setInstallationIdToCrashlytics()
  {
    if (!isCrashlyticsEnabled())
      return false;

    final String installationId = Utils.getInstallationId();
    // If installation id is not found this means id was not
    // generated by alohalytics yet and it is a first run.
    if (TextUtils.isEmpty(installationId))
      return false;

    Crashlytics.setString("AlohalyticsInstallationId", installationId);
    return true;
  }

  private void initMoPub()
  {
    SdkConfiguration sdkConfiguration = new SdkConfiguration
        .Builder(Framework.nativeMoPubInitializationBannerId())
        .build();

    MoPub.initializeSdk(mApplication, sdkConfiguration, null);
  }

  private static class GetAdInfoTask extends AsyncTask<Void, Void, OperationStatus<Boolean, Throwable>>
  {
    @NonNull
    private final ExternalLibrariesMediator mMediator;

    private GetAdInfoTask(@NonNull ExternalLibrariesMediator mediator)
    {
      mMediator = mediator;
    }

    @Override
    protected OperationStatus<Boolean, Throwable> doInBackground(Void... voids)
    {
      try
      {
        boolean trackingEnabled = isAdvertisingTrackingEnabled();
        return new OperationStatus<>(trackingEnabled, null);
      }
      catch (GooglePlayServicesNotAvailableException | IOException | GooglePlayServicesRepairableException e)
      {
        return new OperationStatus<>(false, e);
      }
    }

    private boolean isAdvertisingTrackingEnabled() throws GooglePlayServicesNotAvailableException,
                                                          IOException,
                                                          GooglePlayServicesRepairableException
    {
      AdvertisingIdClient.Info info = AdvertisingIdClient.getAdvertisingIdInfo(mMediator.mApplication);
      return info.isLimitAdTrackingEnabled();
    }

    @Override
    protected void onPostExecute(OperationStatus<Boolean, Throwable> status)
    {
      super.onPostExecute(status);
      if (status.isOk()
          && status.getResult() != null
          && status.getResult()
          && SharedPropertiesUtils.isStatisticsEnabled())
        mMediator.initSensitiveDataStrictLibraries();
    }
  }

  @UiThread
  private static native void nativeInitCrashlytics();
}
