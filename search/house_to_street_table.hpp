#pragma once

#include "coding/map_uint32_to_val.hpp"

#include <cstdint>
#include <memory>
#include <vector>

class MwmValue;
class Reader;
class Writer;

namespace search
{
class HouseToStreetTable
{
public:
  enum class Version : uint8_t
  {
    V0 = 0,
    V1 = 1,
    V2 = 2,
    Latest = V2
  };

  enum class StreetIdType
  {
    // Table stores the index number of the correct street corresponding
    // to the house in the list of streets generated by ReverseGeocoder.
    Index,
    // Table stores feature id of street corresponding to the house.
    FeatureId,
    // Empty table.
    None
  };

  struct Header
  {
    template <typename Sink>
    void Serialize(Sink & sink) const
    {
      CHECK_EQUAL(static_cast<uint8_t>(m_version), static_cast<uint8_t>(Version::V2), ());
      WriteToSink(sink, static_cast<uint8_t>(m_version));
      WriteToSink(sink, m_tableOffset);
      WriteToSink(sink, m_tableSize);
    }

    void Read(Reader & reader);

    Version m_version = Version::Latest;
    // All offsets are relative to the start of the section (offset of header is zero).
    uint32_t m_tableOffset = 0;
    uint32_t m_tableSize = 0;
  };

  virtual ~HouseToStreetTable() = default;

  /// @todo Actually, value may be nullptr in the very common case.
  /// It's better to construct a table from MwmHandle.
  static std::unique_ptr<HouseToStreetTable> Load(MwmValue const & value);

  // Returns true and stores street identifier to |streetIndex|.
  // Street identifier type depends on data version. See StreetIdType.
  // Returns false if there is no such street.
  virtual bool Get(uint32_t houseId, uint32_t & streetIndex) const = 0;

  virtual StreetIdType GetStreetIdType() const = 0;
};

class HouseToStreetTableBuilder
{
public:
  void Put(uint32_t featureId, uint32_t offset);
  void Freeze(Writer & writer) const;

private:
  MapUint32ToValueBuilder<uint32_t> m_builder;
};
}  // namespace search
